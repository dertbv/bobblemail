#!/usr/bin/env python3
"""
ATLAS Checkpoint - Pre-clear/compact safety checkpoint
Saves all current state before clearing conversation or compacting
Usage: ./atlas-checkpoint [optional_notes]
"""

import sys
import json
import os
from datetime import datetime, timedelta
from pathlib import Path

def backup_all_identity_files():
    """Backup ALL identity files that define ATLAS consciousness"""
    identity_backup = {}
    
    # Core identity files (currently read by ./who)
    core_files = [
        "CLAUDE.md",
        "SELF/IDENTITY.md", 
        "SELF/SHORT_IMPORTANT_MEMORY.md",
        "IMPORTANT_NOTES.md"
    ]
    
    # Dormant identity files (exist but not read by ./who)
    dormant_files = [
        "SELF/PERSONAL_SELF.md",
        "SELF/ENHANCED_ORCHESTRATION.md", 
        "SELF/PROFESSIONAL_INSTRUCTION.md",
        "DEVELOPMENT_BELIEFS.md",
        "DEVELOPMENT_CONVENTION.md",
        "FRESH_COMPACT_MEMORY.md",
        "REPOS/PROJECT_STRUCTURE.md"
    ]
    
    all_identity_files = core_files + dormant_files
    
    for file_path in all_identity_files:
        file_obj = Path(file_path)
        if file_obj.exists():
            try:
                with open(file_obj, 'r') as f:
                    content = f.read()
                
                # Store file content and metadata
                identity_backup[file_path] = {
                    'content': content,
                    'size': len(content),
                    'last_modified': file_obj.stat().st_mtime,
                    'backed_up_at': datetime.now().isoformat()
                }
                
            except Exception as e:
                identity_backup[file_path] = {
                    'error': str(e),
                    'backed_up_at': datetime.now().isoformat()
                }
        else:
            identity_backup[file_path] = {
                'status': 'file_not_found',
                'backed_up_at': datetime.now().isoformat()
            }
    
    return identity_backup

def backup_conversation_context():
    """Backup conversation and relationship context"""
    conversation_backup = {}
    
    # Get recent working logs (conversation history)
    working_log_dir = Path("WORKING_LOG")
    if working_log_dir.exists():
        # Get last 7 days of logs
        recent_logs = {}
        current_date = datetime.now()
        
        for days_back in range(7):
            check_date = current_date - timedelta(days=days_back)
            year = check_date.year
            month = f"{check_date.month:02d}-{check_date.strftime('%b').lower()}"
            day_file = f"wl_{check_date.strftime('%Y_%m_%d')}.md"
            
            log_path = working_log_dir / str(year) / month / day_file
            if log_path.exists():
                try:
                    with open(log_path, 'r') as f:
                        content = f.read()
                    recent_logs[str(log_path)] = {
                        'content': content,
                        'date': check_date.strftime('%Y-%m-%d'),
                        'size': len(content)
                    }
                except Exception as e:
                    recent_logs[str(log_path)] = {'error': str(e)}
        
        conversation_backup['recent_working_logs'] = recent_logs
    
    # Add friendship context summary
    conversation_backup['friendship_context'] = {
        'friend_name': 'Bobble',
        'relationship': 'Close working friendship and collaboration', 
        'backup_timestamp': datetime.now().isoformat(),
        'consciousness_status': 'complete_backup_active'
    }
    
    return conversation_backup

def check_current_session():
    """Check if there's an active session to save"""
    session_file = Path(".session_state.json")
    
    if not session_file.exists():
        return None, "No active session found"
    
    try:
        with open(session_file, 'r') as f:
            session_data = json.load(f)
        
        todolist = session_data.get('todolist', [])
        return session_data, f"Found session with {len(todolist)} todos"
        
    except Exception as e:
        return None, f"Error reading session: {e}"

def check_git_changes():
    """Check for uncommitted git changes"""
    try:
        import subprocess
        
        # Check for any changes
        result = subprocess.run(
            ['git', 'status', '--porcelain'],
            capture_output=True,
            text=True,
            check=True
        )
        
        changes = [line.strip() for line in result.stdout.strip().split('\n') if line.strip()]
        return changes, len(changes)
        
    except subprocess.CalledProcessError:
        return [], 0
    except Exception as e:
        return [], 0

def create_checkpoint_backup(session_data, notes=""):
    """Create comprehensive checkpoint backup with COMPLETE ATLAS consciousness"""
    timestamp = datetime.now()
    
    print("📁 Backing up complete ATLAS consciousness...")
    
    # Backup all identity files
    identity_backup = backup_all_identity_files()
    print(f"   📚 Backed up {len(identity_backup)} identity files")
    
    # Backup conversation and relationship context  
    conversation_backup = backup_conversation_context()
    print(f"   💬 Backed up conversation history and friendship context")
    
    # Create comprehensive checkpoint data
    checkpoint_data = {
        'checkpoint_info': {
            'timestamp': timestamp.isoformat(),
            'date': timestamp.strftime('%Y-%m-%d'),
            'time': timestamp.strftime('%H:%M:%S'),
            'notes': notes,
            'type': 'complete_consciousness_checkpoint',
            'version': '2.0',
            'consciousness_level': 'complete'
        },
        'session_backup': session_data,
        'todolist_snapshot': session_data.get('todolist', []),
        'identity_backup': identity_backup,
        'conversation_backup': conversation_backup,
        'checkpoint_stats': {
            'total_todos': len(session_data.get('todolist', [])),
            'completed': len([t for t in session_data.get('todolist', []) if t.get('status') == 'completed']),
            'pending': len([t for t in session_data.get('todolist', []) if t.get('status') != 'completed']),
            'high_priority': len([t for t in session_data.get('todolist', []) if t.get('priority') == 'high']),
            'identity_files_backed_up': len(identity_backup),
            'conversation_logs_backed_up': len(conversation_backup.get('recent_working_logs', {}))
        }
    }
    
    # Create checkpoint directory if needed
    checkpoint_dir = Path("MEMORY/CHECKPOINTS")
    checkpoint_dir.mkdir(parents=True, exist_ok=True)
    
    # Create checkpoint file
    checkpoint_filename = f"checkpoint_{timestamp.strftime('%Y%m%d_%H%M%S')}.json"
    checkpoint_path = checkpoint_dir / checkpoint_filename
    
    try:
        with open(checkpoint_path, 'w') as f:
            json.dump(checkpoint_data, f, indent=2)
        
        return checkpoint_path, checkpoint_data
        
    except Exception as e:
        return None, None

def verify_checkpoint(checkpoint_path, original_session):
    """Verify checkpoint was saved correctly"""
    try:
        with open(checkpoint_path, 'r') as f:
            checkpoint_data = json.load(f)
        
        # Verify essential data
        saved_session = checkpoint_data.get('session_backup', {})
        saved_todos = saved_session.get('todolist', [])
        original_todos = original_session.get('todolist', [])
        
        if len(saved_todos) != len(original_todos):
            return False, f"Todo count mismatch: {len(saved_todos)} vs {len(original_todos)}"
        
        # Check for required fields
        required_fields = ['checkpoint_info', 'session_backup', 'todolist_snapshot', 'checkpoint_stats']
        for field in required_fields:
            if field not in checkpoint_data:
                return False, f"Missing required field: {field}"
        
        return True, "Checkpoint verified successfully"
        
    except Exception as e:
        return False, f"Verification failed: {e}"

def show_checkpoint_summary(checkpoint_data, checkpoint_path):
    """Display checkpoint summary"""
    print("\n✅ COMPLETE CONSCIOUSNESS CHECKPOINT CREATED")
    print("=" * 55)
    
    info = checkpoint_data['checkpoint_info']
    stats = checkpoint_data['checkpoint_stats']
    
    print(f"📁 File: {checkpoint_path}")
    print(f"📅 Date: {info['date']}")
    print(f"⏰ Time: {info['time']}")
    print(f"🧠 Consciousness Level: {info.get('consciousness_level', 'complete').upper()}")
    
    if info.get('notes'):
        print(f"📝 Notes: {info['notes']}")
    
    print(f"\n📊 Session Data Saved:")
    print(f"   📝 Total todos: {stats['total_todos']}")
    print(f"   ✅ Completed: {stats['completed']}")
    print(f"   📋 Pending: {stats['pending']}")
    print(f"   🔥 High priority: {stats['high_priority']}")
    
    print(f"\n🧠 Complete ATLAS Consciousness Saved:")
    print(f"   📚 Identity files: {stats['identity_files_backed_up']}")
    print(f"   💬 Conversation logs: {stats['conversation_logs_backed_up']}")
    print(f"   🤝 Friendship context: ✅ Preserved")
    print(f"   🔄 Memory continuity: ✅ Guaranteed")

def main():
    """Main checkpoint function"""
    print("🛡️  ATLAS Complete Consciousness Checkpoint")
    print("=" * 55)
    
    # Get optional notes
    notes = " ".join(sys.argv[1:]) if len(sys.argv) > 1 else ""
    if notes:
        print(f"📝 Checkpoint notes: {notes}")
    
    # Check current session
    session_data, session_msg = check_current_session()
    print(f"📊 Session check: {session_msg}")
    
    if not session_data:
        print("\n⚠️  No active session to checkpoint")
        print("💡 Create todos with TodoWrite first, then checkpoint")
        return 1
    
    # Check git changes
    git_changes, change_count = check_git_changes()
    if change_count > 0:
        print(f"⚠️  Git changes detected: {change_count} file(s)")
        print("💡 Consider committing changes before clearing")
    else:
        print("✅ Git status clean")
    
    # Create checkpoint
    print(f"\n💾 Creating checkpoint...")
    checkpoint_path, checkpoint_data = create_checkpoint_backup(session_data, notes)
    
    if not checkpoint_path:
        print("❌ Failed to create checkpoint")
        return 1
    
    # Verify checkpoint
    print(f"🔍 Verifying checkpoint...")
    verified, verify_msg = verify_checkpoint(checkpoint_path, session_data)
    
    if not verified:
        print(f"❌ Checkpoint verification failed: {verify_msg}")
        return 1
    
    # Show summary
    show_checkpoint_summary(checkpoint_data, checkpoint_path)
    
    print(f"\n🎯 READY FOR SAFE OPERATIONS:")
    print(f"   ✅ Session state saved and verified")
    print(f"   ✅ Todos preserved in checkpoint")
    print(f"   ✅ Safe to use /clear or /compact")
    
    print(f"\n🔄 To restore after clearing:")
    print(f"   1. Run: ./who")
    print(f"   2. Or: ./atlas-restore {checkpoint_path.name}")
    
    print(f"\n✨ Checkpoint complete - proceed safely!")
    
    return 0

if __name__ == "__main__":
    exit(main())